## 广度遍历
- 简介    
　　广度优先搜索BFS(Breadth-First-Search)，有称为宽度搜索算法。简单的思考，可以想象一个树。沿着树根开始，一层一层的遍历所有节点，直到找到想要到达的终点，或所有节点均被访问，则算法中止。  
　　由于BFS是分层查找的方法，因此在寻找最短路径中用途广泛。当遍历到终点时，此时从树根到终点的路径总是最短的。  
　　可以想象一下树一层一层往下，当到达某个节点时，此节点到根的距离，一定是最短的那条路。
![](https://ws4.sinaimg.cn/large/006tNc79gy1fq2qxq5exbj30om0e043o.jpg)  
　　**先访问的临节点的临节点先访问，后访问的临节点的临节点后访问。**
- 算法公式  
    - 公式1：层次遍历  
    　　使用一个队列，先进先出，首先将根入队，然后查看当前队列是否为空，不为空的情况下，将队首出队，访问队首，然后将与队首相邻的节点依次入队。

    ```
    bfs (graph g, strcut node *x)
    {
        if (x未被访问) {
            q->insert(x); /* x入队 */
        }
        while (q不等于空) {
            y=q->remove();  /* 出队 */
            visit(y);
            mark_visited(y);
            if (y == to_find) {
                return // return 权重相同，最短路径，不返回，所有路径
            }
            for(z=与y相邻；z未被访问; z=y相邻) {
                q->insert(z) /* z入队 */
                z->parent=y;
                z->depth = y->depth++;
            }
        }
    }
    ```
    　　一个简单的想法是，将层次遍历下一层的节点，把相邻节点的parent设置为上一层节点即可。但这只能争对，权重相同的树/图，如果权重不同，则不能这么计算。  
    ```


   
